package generator

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"distui/internal/models"
)

func GenerateGoReleaserConfig(project *models.ProjectInfo, config *models.ProjectConfig) (string, error) {
	if project == nil || config == nil {
		return "", fmt.Errorf("project and config required")
	}

	var b strings.Builder

	if project.Repository != nil {
		b.WriteString(fmt.Sprintf("# Generated by distui - https://github.com/%s/%s\n", project.Repository.Owner, project.Repository.Name))
	} else {
		b.WriteString("# Generated by distui\n")
	}
	b.WriteString("# Edit as needed, distui won't overwrite manual changes\n\n")

	b.WriteString("version: 2\n\n")

	b.WriteString("before:\n")
	b.WriteString("  hooks:\n")
	if config.Config != nil && config.Config.Release != nil && !config.Config.Release.SkipTests {
		b.WriteString("    - go test ./...\n")
	}
	b.WriteString("    - go mod tidy\n\n")

	b.WriteString("builds:\n")
	b.WriteString("  - env:\n")
	b.WriteString("      - CGO_ENABLED=0\n")
	b.WriteString("    goos:\n")
	b.WriteString("      - linux\n")
	b.WriteString("      - darwin\n")
	b.WriteString("      - windows\n")
	b.WriteString("    goarch:\n")
	b.WriteString("      - amd64\n")
	b.WriteString("      - arm64\n")

	if project.Binary != nil && project.Binary.Name != "" {
		b.WriteString(fmt.Sprintf("    binary: %s\n", project.Binary.Name))
	}
	b.WriteString("\n")

	b.WriteString("archives:\n")
	b.WriteString("  - format: tar.gz\n")
	b.WriteString("    files:\n")
	b.WriteString("      - none*\n")
	b.WriteString("    rlcp: true\n\n")

	b.WriteString("checksum:\n")
	b.WriteString("  name_template: 'checksums.txt'\n\n")

	b.WriteString("changelog:\n")
	if config.Config != nil && config.Config.Release != nil && config.Config.Release.GenerateChangelog {
		b.WriteString("  sort: asc\n")
		b.WriteString("  filters:\n")
		b.WriteString("    exclude:\n")
		b.WriteString("      - '^docs:'\n")
		b.WriteString("      - '^test:'\n\n")
	} else {
		b.WriteString("  skip: true\n\n")
	}

	if config.Config != nil && config.Config.Distributions.Homebrew != nil && config.Config.Distributions.Homebrew.Enabled {
		b.WriteString("brews:\n")
		b.WriteString("  - repository:\n")
		b.WriteString(fmt.Sprintf("      owner: %s\n", strings.Split(config.Config.Distributions.Homebrew.TapRepo, "/")[0]))
		b.WriteString(fmt.Sprintf("      name: %s\n", strings.Split(config.Config.Distributions.Homebrew.TapRepo, "/")[1]))
		b.WriteString("    directory: Formula\n")
		b.WriteString("    homepage: https://github.com/" + project.Repository.Owner + "/" + project.Repository.Name + "\n")
		b.WriteString("    description: " + project.Module.Name + "\n")
		b.WriteString("    license: MIT\n\n")
	}

	if config.Config != nil && config.Config.Distributions.NPM != nil && config.Config.Distributions.NPM.Enabled {
		b.WriteString("# NPM publishing requires package.json in repo\n")
		b.WriteString("# Run 'distui generate package.json' if not present\n\n")
	}

	return b.String(), nil
}

func WriteGoReleaserConfig(projectPath string, content string) error {
	configPath := filepath.Join(projectPath, ".goreleaser.yaml")

	if _, err := os.Stat(configPath); err == nil {
		return fmt.Errorf("file already exists: %s", configPath)
	}

	if err := os.WriteFile(configPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("writing goreleaser config: %w", err)
	}

	return nil
}

func WriteGoReleaserConfigForce(projectPath string, content string) error {
	configPath := filepath.Join(projectPath, ".goreleaser.yaml")

	if err := os.WriteFile(configPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("writing goreleaser config: %w", err)
	}

	return nil
}