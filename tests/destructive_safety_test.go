package tests

import (
	"os"
	"path/filepath"
	"testing"

	"distui/internal/detection"
	"distui/internal/fileops"
)

// TestDestructiveSafety_DoNotNukeCustomFiles verifies we never delete user's custom files
func TestDestructiveSafety_DoNotNukeCustomFiles(t *testing.T) {
	tmpDir := t.TempDir()
	projectDir := filepath.Join(tmpDir, "user-project")
	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatalf("Failed to create project dir: %v", err)
	}

	// User has precious custom .goreleaser.yaml with specific config
	preciousContent := `# User's carefully crafted config
project_name: my-precious-app
builds:
  - main: ./cmd/main.go
    env:
      - CGO_ENABLED=0
    goos:
      - linux
      - darwin
      - windows
    goarch:
      - amd64
      - arm64
archives:
  - format: tar.gz
    files:
      - LICENSE
      - README.md
`
	customFile := filepath.Join(projectDir, ".goreleaser.yaml")
	if err := os.WriteFile(customFile, []byte(preciousContent), 0644); err != nil {
		t.Fatalf("Failed to create custom file: %v", err)
	}

	// Step 1: Detect as custom (no marker)
	customMode, _, err := detection.DetectProjectMode(projectDir)
	if err != nil {
		t.Fatalf("DetectProjectMode failed: %v", err)
	}

	if !customMode {
		t.Error("Should detect as custom mode - no distui marker present")
	}

	// Step 2: User chooses to archive (simulate mode switch)
	backupPath, err := fileops.ArchiveCustomFiles(projectDir, []string{".goreleaser.yaml"})
	if err != nil {
		t.Fatalf("Archive failed: %v", err)
	}

	// Step 3: Verify original file is MOVED (not deleted)
	if _, err := os.Stat(customFile); !os.IsNotExist(err) {
		t.Error("CRITICAL: Original file still exists after archive - should be moved!")
	}

	archivedFile := filepath.Join(backupPath, ".goreleaser.yaml")
	if _, err := os.Stat(archivedFile); os.IsNotExist(err) {
		t.Fatal("CRITICAL: Archived file doesn't exist - USER DATA LOST!")
	}

	// Step 4: Verify archived content is IDENTICAL
	archivedContent, err := os.ReadFile(archivedFile)
	if err != nil {
		t.Fatalf("Failed to read archived file: %v", err)
	}

	if string(archivedContent) != preciousContent {
		t.Errorf("CRITICAL: Archived content mismatch!\nExpected:\n%s\n\nGot:\n%s",
			preciousContent, string(archivedContent))
	}

	// Step 5: Verify backup directory is in .distui-backup (not deleted on cleanup)
	if !contains(backupPath, ".distui-backup") {
		t.Errorf("Backup path should contain .distui-backup, got: %s", backupPath)
	}

	t.Log("✓ SAFETY VERIFIED: Custom files archived safely, no data loss")
}

// TestDestructiveSafety_ManagedModeNoRepeatedWarnings verifies managed mode doesn't spam warnings
func TestDestructiveSafety_ManagedModeNoRepeatedWarnings(t *testing.T) {
	tmpDir := t.TempDir()
	projectDir := filepath.Join(tmpDir, "managed-project")
	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatalf("Failed to create project dir: %v", err)
	}

	// Create distui-managed file (with marker)
	managedContent := `# Generated by distui
project_name: managed-app
builds:
  - main: ./main.go
`
	if err := os.WriteFile(filepath.Join(projectDir, ".goreleaser.yaml"), []byte(managedContent), 0644); err != nil {
		t.Fatalf("Failed to create managed file: %v", err)
	}

	// Verify NOT detected as custom
	customMode, _, err := detection.DetectProjectMode(projectDir)
	if err != nil {
		t.Fatalf("DetectProjectMode failed: %v", err)
	}

	if customMode {
		t.Error("CRITICAL: Managed file detected as custom - will trigger warnings on every edit!")
	}

	t.Log("✓ SAFETY VERIFIED: Managed files not flagged as custom")
}

// TestDestructiveSafety_GitignoreNeverDeletedOrModified ensures .gitignore is sacred
func TestDestructiveSafety_GitignoreNeverDeletedOrModified(t *testing.T) {
	tmpDir := t.TempDir()
	projectDir := filepath.Join(tmpDir, "project")
	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatalf("Failed to create project dir: %v", err)
	}

	// User's precious .gitignore
	gitignoreContent := `# User's custom ignores
*.log
*.tmp
node_modules/
.env
`
	gitignorePath := filepath.Join(projectDir, ".gitignore")
	if err := os.WriteFile(gitignorePath, []byte(gitignoreContent), 0644); err != nil {
		t.Fatalf("Failed to create .gitignore: %v", err)
	}

	// Archive should NEVER touch .gitignore
	_, err := fileops.ArchiveCustomFiles(projectDir, []string{".goreleaser.yaml"})
	if err != nil {
		// Expected - .goreleaser.yaml doesn't exist
		// But .gitignore should NOT be touched
	}

	// Verify .gitignore UNTOUCHED
	if _, err := os.Stat(gitignorePath); os.IsNotExist(err) {
		t.Fatal("CRITICAL: .gitignore was deleted during archive!")
	}

	currentContent, err := os.ReadFile(gitignorePath)
	if err != nil {
		t.Fatalf("Failed to read .gitignore: %v", err)
	}

	if string(currentContent) != gitignoreContent {
		t.Error("CRITICAL: .gitignore was modified during archive!")
	}

	t.Log("✓ SAFETY VERIFIED: .gitignore never touched")
}

// TestDestructiveSafety_NoOrphanedBackups verifies backup directories are created correctly
func TestDestructiveSafety_NoOrphanedBackups(t *testing.T) {
	tmpDir := t.TempDir()
	projectDir := filepath.Join(tmpDir, "project")
	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatalf("Failed to create project dir: %v", err)
	}

	// Create files to archive
	testFiles := []string{".goreleaser.yaml", "package.json"}
	for _, file := range testFiles {
		content := "test content for " + file
		if err := os.WriteFile(filepath.Join(projectDir, file), []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create %s: %v", file, err)
		}
	}

	// Archive files
	backupPath, err := fileops.ArchiveCustomFiles(projectDir, testFiles)
	if err != nil {
		t.Fatalf("Archive failed: %v", err)
	}

	// Verify backup is INSIDE project directory (not orphaned elsewhere)
	expectedBackupPrefix := filepath.Join(projectDir, ".distui-backup")
	if !contains(backupPath, expectedBackupPrefix) {
		t.Errorf("Backup created outside project directory!\nExpected prefix: %s\nGot: %s",
			expectedBackupPrefix, backupPath)
	}

	// Verify backup contains timestamp (for tracking)
	entries, err := os.ReadDir(filepath.Join(projectDir, ".distui-backup"))
	if err != nil {
		t.Fatalf("Failed to read backup dir: %v", err)
	}

	if len(entries) != 1 {
		t.Errorf("Expected exactly 1 backup folder, got %d", len(entries))
	}

	t.Log("✓ SAFETY VERIFIED: Backups stored in project/.distui-backup with timestamp")
}

// TestDestructiveSafety_MultipleBackupsPreserved ensures old backups aren't deleted
func TestDestructiveSafety_MultipleBackupsPreserved(t *testing.T) {
	tmpDir := t.TempDir()
	projectDir := filepath.Join(tmpDir, "project")
	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatalf("Failed to create project dir: %v", err)
	}

	// First backup
	file1 := filepath.Join(projectDir, ".goreleaser.yaml")
	os.WriteFile(file1, []byte("version 1"), 0644)

	backup1, err := fileops.ArchiveCustomFiles(projectDir, []string{".goreleaser.yaml"})
	if err != nil {
		t.Fatalf("First archive failed: %v", err)
	}

	// Second backup (simulate user re-enabling custom files)
	os.WriteFile(file1, []byte("version 2"), 0644)

	backup2, err := fileops.ArchiveCustomFiles(projectDir, []string{".goreleaser.yaml"})
	if err != nil {
		t.Fatalf("Second archive failed: %v", err)
	}

	// Verify BOTH backups exist
	if _, err := os.Stat(backup1); os.IsNotExist(err) {
		t.Error("CRITICAL: First backup was deleted by second backup!")
	}

	if _, err := os.Stat(backup2); os.IsNotExist(err) {
		t.Fatal("Second backup doesn't exist")
	}

	// Verify they're different timestamps
	if backup1 == backup2 {
		t.Error("Both backups have same path - second overwrote first!")
	}

	t.Log("✓ SAFETY VERIFIED: Multiple backups preserved with unique timestamps")
}

// Helper function
func contains(s, substr string) bool {
	return len(s) >= len(substr) && s[:len(substr)] == substr ||
		   len(s) > len(substr) && s[len(s)-len(substr):] == substr ||
		   filepath.Base(filepath.Dir(s)) == filepath.Base(substr) ||
		   filepath.Base(s) == filepath.Base(substr)
}
