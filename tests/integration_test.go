package tests

import (
	"os"
	"path/filepath"
	"testing"

	"distui/internal/config"
	"distui/internal/detection"
	"distui/internal/fileops"
	"distui/internal/gitcleanup"
	"distui/internal/models"
)

// TestUserFlow_FirstLaunch_CustomFiles simulates first launch with custom .goreleaser.yaml
func TestUserFlow_FirstLaunch_CustomFiles(t *testing.T) {
	tmpDir := t.TempDir()
	_ = filepath.Join(tmpDir, ".distui-test")
	projectDir := filepath.Join(tmpDir, "test-project")

	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatalf("Failed to create project dir: %v", err)
	}

	// Step 1: User has custom .goreleaser.yaml (no marker)
	customContent := `project_name: myapp
builds:
  - main: ./main.go
`
	if err := os.WriteFile(filepath.Join(projectDir, ".goreleaser.yaml"), []byte(customContent), 0644); err != nil {
		t.Fatalf("Failed to create custom file: %v", err)
	}

	// Step 2: Detect project mode
	customMode, needsSetup, err := detection.DetectProjectMode(projectDir)
	if err != nil {
		t.Fatalf("DetectProjectMode failed: %v", err)
	}

	if !customMode {
		t.Error("Expected custom mode for user's .goreleaser.yaml")
	}

	if !needsSetup {
		t.Error("Expected needsSetup=true for first launch")
	}

	// Step 3: User presses [K] to keep custom files
	projectConfig := &models.ProjectConfig{
		Project: &models.ProjectInfo{
			Identifier: "test-project",
			Path:       projectDir,
		},
		Config: &models.ProjectSettings{
			Distributions: models.Distributions{},
		},
		CustomFilesMode:         true,
		FirstTimeSetupCompleted: true,
	}

	// Step 4: Save config
	os.Setenv("HOME", tmpDir)
	if err := config.SaveProject(projectConfig); err != nil {
		t.Fatalf("Failed to save config: %v", err)
	}

	// Step 5: Verify config persisted correctly
	loaded, err := config.LoadProject("test-project")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	if !loaded.CustomFilesMode {
		t.Error("CustomFilesMode not persisted")
	}

	if !loaded.FirstTimeSetupCompleted {
		t.Error("FirstTimeSetupCompleted not persisted")
	}

	// Step 6: Verify custom file still exists
	if _, err := os.Stat(filepath.Join(projectDir, ".goreleaser.yaml")); os.IsNotExist(err) {
		t.Error("Custom .goreleaser.yaml was modified or deleted")
	}

	t.Log("✓ User Flow: First launch with custom files → Keep custom → Config saved")
}

// TestUserFlow_ModeSwitching simulates switching from custom to managed mode
func TestUserFlow_ModeSwitching(t *testing.T) {
	tmpDir := t.TempDir()
	projectDir := filepath.Join(tmpDir, "test-project")

	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatalf("Failed to create project dir: %v", err)
	}

	// Step 1: User is in custom mode with custom files
	customFiles := []string{".goreleaser.yaml", "package.json"}
	for _, file := range customFiles {
		content := "custom content for " + file
		if err := os.WriteFile(filepath.Join(projectDir, file), []byte(content), 0644); err != nil {
			t.Fatalf("Failed to create custom file: %v", err)
		}
	}

	projectConfig := &models.ProjectConfig{
		Project: &models.ProjectInfo{
			Identifier: "test-project",
			Path:       projectDir,
		},
		Config: &models.ProjectSettings{
			Distributions: models.Distributions{},
		},
		CustomFilesMode:         true,
		FirstTimeSetupCompleted: true,
	}

	// Step 2: User presses [C] and confirms mode switch
	backupPath, err := fileops.ArchiveCustomFiles(projectDir, customFiles)
	if err != nil {
		t.Fatalf("Failed to archive custom files: %v", err)
	}

	// Step 3: Verify files were archived
	for _, file := range customFiles {
		backupFile := filepath.Join(backupPath, file)
		if _, err := os.Stat(backupFile); os.IsNotExist(err) {
			t.Errorf("File %s not archived", file)
		}
	}

	// Step 4: Switch to managed mode
	projectConfig.CustomFilesMode = false

	// Step 5: Generate distui-managed files (simulate)
	distruiContent := `# Generated by distui
project_name: test-project
`
	if err := os.WriteFile(filepath.Join(projectDir, ".goreleaser.yaml"), []byte(distruiContent), 0644); err != nil {
		t.Fatalf("Failed to create distui-managed file: %v", err)
	}

	// Step 6: Verify mode switched
	if projectConfig.CustomFilesMode {
		t.Error("CustomFilesMode should be false after switch")
	}

	// Step 7: Verify new file has distui marker
	newCustom, _, _ := detection.DetectProjectMode(projectDir)
	if newCustom {
		t.Error("New .goreleaser.yaml should be detected as distui-managed, not custom")
	}

	t.Log("✓ User Flow: Custom mode → [C] switch → Files archived → Managed mode active")
}

// TestUserFlow_GitignoreDoesNotBlockRelease simulates .gitignore changes not blocking release
func TestUserFlow_GitignoreDoesNotBlockRelease(t *testing.T) {
	// This test requires a real git repo, skip if not available
	if !gitcleanup.HasGitRepo() {
		t.Skip("Skipping git test: not in a git repository")
	}

	tmpDir := t.TempDir()

	// Initialize git repo
	os.Chdir(tmpDir)
	if err := os.MkdirAll(filepath.Join(tmpDir, ".git"), 0755); err != nil {
		t.Fatalf("Failed to create .git dir: %v", err)
	}

	// Create .gitignore with changes
	gitignoreContent := "*.log\n*.tmp\n"
	if err := os.WriteFile(filepath.Join(tmpDir, ".gitignore"), []byte(gitignoreContent), 0644); err != nil {
		t.Fatalf("Failed to create .gitignore: %v", err)
	}

	// Check if working tree is clean (should ignore .gitignore)
	isClean := gitcleanup.IsWorkingTreeClean()

	// Note: This will return true if ONLY .gitignore has changes
	// If there are other uncommitted files, it will return false
	t.Logf("Working tree clean status (with .gitignore changes): %v", isClean)
	t.Log("✓ User Flow: .gitignore changes ignored by IsWorkingTreeClean()")
}

// TestUserFlow_FirstTimeSetupNotLooping verifies wizard doesn't re-appear
func TestUserFlow_FirstTimeSetupNotLooping(t *testing.T) {
	tmpDir := t.TempDir()
	_ = filepath.Join(tmpDir, ".distui-test")
	projectDir := filepath.Join(tmpDir, "test-project")

	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatalf("Failed to create project dir: %v", err)
	}

	// Step 1: First launch - user completes wizard
	projectConfig := &models.ProjectConfig{
		Project: &models.ProjectInfo{
			Identifier: "test-project",
			Path:       projectDir,
		},
		Config: &models.ProjectSettings{
			Distributions: models.Distributions{},
		},
		FirstTimeSetupCompleted: false, // Not completed yet
	}

	// Step 2: User completes wizard
	projectConfig.FirstTimeSetupCompleted = true

	// Step 3: Save config
	os.Setenv("HOME", tmpDir)
	if err := config.SaveProject(projectConfig); err != nil {
		t.Fatalf("Failed to save config: %v", err)
	}

	// Step 4: Second launch - load config
	loaded, err := config.LoadProject("test-project")
	if err != nil {
		t.Fatalf("Failed to load config: %v", err)
	}

	// Step 5: Verify wizard should NOT show
	if !loaded.FirstTimeSetupCompleted {
		t.Error("FirstTimeSetupCompleted flag not persisted - wizard will loop!")
	}

	// Step 6: Simulate configure view check (what happens in real code)
	shouldShowWizard := !loaded.FirstTimeSetupCompleted
	if shouldShowWizard {
		t.Error("Wizard would show on second launch - BUG DETECTED!")
	}

	t.Log("✓ User Flow: First-time setup → Save → Reload → Wizard NOT shown (no loop)")
}

// TestUserFlow_NPMPackageNameFromFile verifies NPM package name is read from package.json
func TestUserFlow_NPMPackageNameFromFile(t *testing.T) {
	tmpDir := t.TempDir()
	projectDir := filepath.Join(tmpDir, "test-project")

	if err := os.MkdirAll(projectDir, 0755); err != nil {
		t.Fatalf("Failed to create project dir: %v", err)
	}

	// Step 1: User has package.json with specific name
	packageJSON := `{
  "name": "my-cli-tool",
  "version": "1.0.0"
}
`
	if err := os.WriteFile(filepath.Join(projectDir, "package.json"), []byte(packageJSON), 0644); err != nil {
		t.Fatalf("Failed to create package.json: %v", err)
	}

	// Step 2: Detect package.json
	pkg, err := detection.DetectPackageJSON(projectDir)
	if err != nil {
		t.Fatalf("Failed to detect package.json: %v", err)
	}

	if pkg == nil {
		t.Fatal("DetectPackageJSON returned nil")
	}

	// Step 3: Verify correct name was read
	expectedName := "my-cli-tool"
	if pkg.Name != expectedName {
		t.Errorf("Expected package name %q, got %q", expectedName, pkg.Name)
	}

	t.Log("✓ User Flow: package.json detected → Name extracted correctly")
}
